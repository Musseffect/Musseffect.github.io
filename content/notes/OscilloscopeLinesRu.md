Осциллографы - устройства, использующиеся для отображения одномерных сигналов и двухмерных кривых.
В аналоговом CRT осциллографе происходит обстрел люминисцентного экрана пушкой, излучающей электроны. Электроны отклоняются магнитным или электрическим полем в соответствии с входным сигналом по X И Y координатам.
Для того, чтобы нарисовать изображение, похожее на картинку с экрана аналогового осциллографа нужно использовать немного маг, тьфу,  математики.
Каждая кривая является результатом непрерывного движения точки $\vec{p}(t)$ в каком-то промежутке времени. 
Каждое мгновение эта точка освещает поверхность экрана и образует пятно в соответствии с каким-то распределением мгновенной интенсивности.
Это распределение должно зависить только от расстояния между точкой на поверхности экрана $\vec{p}_{scr}=vec2(x,y)$ и двигающейся точкой $\vec{p}(t)$.

Примером подходящего реалистичного распределения является нормальное распределение с нулевым мат. ожиданием:

$$
I_{radial}(r)=\frac{1}{\sigma \sqrt{2\pi}}e^{-\frac{r^2}{2\sigma^2}}\\r(\vec{p}(t),\vec{p}_{scr})=\sqrt{({(\vec{p}(t).x-x)}^2+{(\vec{p}(t).y-y)}^2}
$$

Параметр $\sigma$ (дисперсия) регулирует размер пятна.

![gaussian](https://drive.google.com/uc?id=1WVYCcr10coVR0wyPx6NfsaYvC2F5j5IG "gaussian")

[figure]
**Рис. 1** - Гауссиана с единичной дисперсией
[/figure]

Выражение для интенсивности можно упростить, рассматривая только линейное движение для интервала $[t_0,t_0 + \Delta t]$
и перейдя в локальную систему координат с центром $\vec{p}(t_0)$ и направлениями $\vec{l}$ в качестве оси $\vec{x}$ и $\vec{n}$ в качестве оси $\vec{y}$, где:

$$
\vec{l}=(\vec{p}(t_0 + \Delta t)-\vec{p}(t_0))\frac{1}{\|\vec{p}(t_0 + \Delta t)-\vec{p}(t_0)\|}\\\vec{n}=vec2(-\vec{p}(t_0 + \Delta t).y+\vec{p}(t_0).y,\vec{p}(t_0 + \Delta t).x-\vec{p}(t_0).x)\frac{1}{\|\vec{p}(t_0 + \Delta t)-\vec{p}(t_0)\|}
$$

$\vec{l}$ - вектор касательной к прямой $(\vec{p(t_0)},\vec{p(t_0 + \Delta t)})$, $\vec{n}$ - вектор нормали. Вектор нормали можно повернуть на 180 градусов, поскольку значение $y$ при расчёте расстояния возводится в квадрат.

В локальной системе координат выражение для расстояния:

$$
\vec{p}_{loc} = vec2(dot(\vec{p}_{scr}-\vec{p}(t_0),\vec{l}),dot(\vec{p}_{scr}-\vec{p}(t_0),\vec{n})) = vec2(x_{loc},y_{loc})\\
r(t,\vec{p}_{scr})=\sqrt{(\frac{t-t_0}{\Delta t}d - x_{loc})^2+y_{loc}^2}\\d = \|\vec{p}(t_0 + \Delta t)-\vec{p}(t_0)\|
$$

Таким образом интенсивность в момент времени $t$ для $\vec{p}_{scr}$ и $\vec{p}(t)$:

$$
I(\vec{p}(t),\vec{p}_{scr})=\frac{1}{\sigma \sqrt{2\pi}}e^{-\frac{r(t,\vec{p}_{loc})^2}{2\sigma^2}}
$$ 

Изображение на экране должно постепенно затухать.

Самый простой способ это реализовать - экспоненциальное затухание.

Интенсивность изображения $i$ в момент времени $T + \Delta T$:

$$
i(T+\Delta T) = i(T)e^{-f\Delta T},
$$

  где $f$ - коэффициент затухания. Чем $f$ больше, тем быстрее затухает изображение, если его перестать подсвечивать.

Этот способ затухания удобен тем, что он работает со значениями $i$ в дискретные моменты времени.

Допустим мы знаем изображение $S_i(\vec{p}_{scr})$ в прошлый момент времени $t_i$ и хотим получить изображение на осциллографе $S_{i+1}(\vec{p}_{scr})$ в момент времени $t_{i+1}$. Поскольку на компьютере мы работаем с растровыми изображениями, то будем считать значения только для отдельных дискретных точек.
Формула для расчёта цвета экрана с учётом затухания изображения и линий, нарисованных за последний кадр:

$$
S_{i+1}(\vec{p}_{scr})=S_{i}(\vec{p}_{scr})e^{-f \Delta T}+\int_{T}^{T+\Delta T} I(\vec{p}(t),\vec{p}_{scr}) e^{-f (T + \Delta T - t)} dt
$$

Аналитическое решение для интеграла:

$$
\int_{T}^{T+\Delta T} I(\vec{p}(t),\vec{p}_{scr}) e^{-f(T + \Delta T - t)} dt = \frac{1}{2d} e^{\frac{(f \Delta t \sigma)^2}{2d^2}} e^{\frac{f \Delta t (x_{loc}-d)}{d}} e^{-\frac{y_{loc}^2}{2 \sigma^2}} (erf(\frac{d x_{loc}+ f \Delta t \sigma^2}{\sqrt{2} d \sigma})-erf(\frac{f \Delta t \sigma^2+d (x_{loc}-d)}{\sqrt{2} d \sigma}))
$$

$erf(x)$ - функция ошибки, её можно вычислить приближённо с хорошей точностью.

![errorfunc](https://drive.google.com/uc?id=1oTHhVXYVBDweXrQM0zz9cfy8cXQYagqt "error function")

[figure]
**Рис. 2** - Функция ошибки
[/figure]

Можно использовать упрощённую формулу, не учитывающую затухание линий:

$$
S_{i+1}(\vec{p}_{scr})=S_{i}(\vec{p}_{scr})e^{-f \Delta T}+\int_{T}^{T+\Вelta T} I(\vec{p}(t),\vec{p}_{scr}) dt
$$

Аналитическое решение для интеграла:

$$
\int_{T}^{T+\delta T} I(\vec{p}(t),\vec{p}_{scr}) = \frac{1}{2d} e^{-\frac{y_{loc}^2}{2 \sigma^2}} (erf(\frac{x_{loc}}{\sqrt{2}\sigma})-erf(\frac{x_{loc}-d}{\sqrt{2}\sigma})
$$

Код *glsl*:

```glsl
//функция ошибки
float erf(float x)
{
    float s = sign(x), a = abs(x);
    x = 1.0 + (0.278393 + (0.230389 + 0.078108 * (a * a)) * a) * a;
    x *= x;
    return s - s / (x * x);
}
//интенсивность с упрощённой формулой
float intensity(float d,vec2 p,float sigma)
{
    float f = 1.0/(sqrt(2.)*sigma);
	return (erf(p.x*f)-erf((p.x-d)*f))
	*exp(-p.y*p.y/(2.*sigma*sigma))/(2.*d);
}
//интенсивность с полной формулой
float intensityFading(float d,vec2 p,float sigma,float dt,float fadeRate)
{
    float f = 1.0/(sqrt(2.)*d*sigma);
    float fd = fadeRate*dt;
	return (erf((p.x*d+fd*sigma*sigma)*f)-erf(((p.x-d)*d+fd*sigma*sigma)*f))
	*exp(-p.y*p.y/(2.*sigma*sigma))
        *exp(fd*(fd*sigma*sigma*0.5/d+(p.x-d))/d)/(2.*d);
}
```
![example](https://drive.google.com/uc?id=106uizvMSI3K5duplAgYUSyJwmAeVXSBi "example")

[figure]
**Рис. 3** - Результат в Shadertoy
[/figure]

Из рисунка видно, что при одном и том же $\Delta t$ фрагмент линии тем светлее, чем он короче, то есть чем меньше скорость перемещения подсвечиваемой точки на данном фрагменте. Стоит отметить, что при относительно быстрой отрисовке линий визуальная разница между упрощённой и полной формулой незаметна.
